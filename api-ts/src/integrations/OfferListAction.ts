// PLEASE DO NOT EDIT THIS FILE, THIS IS GENERATED BY NATIVEBLOCKS

interface IProperty {
  key: string;
  value: string;
  type: string;
}

interface IData {
  key: string;
  value: any;
  type: string;
}

interface ITrigger {
  name: string;
  keyType: string;
  then: string;
  properties: IProperty[];
  data: IData[];
  triggers: ITrigger[];
}

interface IEvent {
  event: string;
}

export class OfferListAction {
  private readonly keyType: string;
  private readonly integrationVersion: number;
  private properties: IProperty[];
  private data: IData[];
  private readonly events: IEvent[];
  private triggers: ITrigger[];
  private readonly name: string;
  private readonly then: string;

  constructor(config: {
    name: string;
    then: string;
  } = {} as any) {
    this.keyType = "OFFER_LIST";
    this.triggers = [];
    this.name = config.name;
    this.then = config.then;
    this.integrationVersion = 1;
    this.properties = [];
    this.data = [];
    this.events = [];
    const initialProperties: IProperty[] = [
      {key: "endpoint", value: "", type: "STRING"},
    ];
    this.properties.push(...initialProperties);
    const initialData: IData[] = [];
    this.data.push(...initialData);
    const initialEvents: IEvent[] = [
      {event: "END"},
    ];
    this.events.push(...initialEvents);
  }

  public addTrigger(trigger: ITrigger): this {
    if (!this.isValidEvent(trigger.then)) {
      throw new Error(`Invalid then: ${trigger.then}. Must be one of: ${this.events.map((e) => e.event).join(", ")}`);
    }
    if (!this.isValidTrigger(trigger)) {
      throw new Error("Invalid trigger: Trigger must be an object with name, keyType, and then");
    }
    this.triggers.push({
      name: trigger.name,
      keyType: trigger.keyType,
      then: trigger.then,
      properties: trigger.properties || [],
      data: trigger.data || [],
      triggers: trigger.triggers || []
    });
    return this;
  }

  public modifyProperty(key: string, value: string): this {
    const propIndex = this.properties.findIndex((p) => p.key === key);
    if (propIndex !== -1) {
      this.properties[propIndex] = {...this.properties[propIndex], value};
    }
    return this;
  }

  public build(): any {
    return {
      keyType: this.keyType,
      name: this.name,
      then: this.then,
      triggers: this.triggers,
      data: this.data,
      properties: this.properties,
      integrationVersion: this.integrationVersion,
    };
  }

  private isValidEvent(eventName: string): boolean {
    return this.events.some((e) => e.event === eventName);
  }

  private isValidTrigger(trigger: ITrigger): boolean {
    return Boolean(trigger &&
      typeof trigger === "object" &&
      trigger.name &&
      trigger.keyType &&
      trigger.then);
  }
}
